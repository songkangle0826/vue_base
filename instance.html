<!Doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
	<!-- 这里就是View(视图)层 -->
	<div id="app">
		{{ name }}-{{ age }}
	</div>
	<script src="./node_modules/vue/dist/vue.js"></script>
	<script>
		let vm = new Vue({
			el: '#app',
			data(){
				return {
					name: 'zf',
					// age: {}
				}
			}
		})
		// 1).vue有个特点,不会在本轮代码执行的时候,去重新渲染DOM
		// 2).下一个事件环中执行,(promise.then, mutationobserver,setimmdediate,settimeout)
		
		// 这里会等待数据更新后重新调用回调函数
		// 视图是异步更新的
		vm.$watch("name",function(newValue,oldValue){
			console.log(newValue,oldValue)
		})
		// vm.name = '哈哈哈'
		// vm.name = "哈哈哈1"


		// 数据更新后会有一个队列, 将watch的的callback放到队列中,会将nextTick往后叠加
		vm.$nextTick(()=>{	
			console.log(vm.$el.innerHTML)
		})

		// console.log(vm.$el);			// 渲染真实的dom元素
		// debugger;




		// vm.$data;			// 代表当前实例的数据
		console.log('vm.$data',vm.$data);
		console.log('vm.$options',vm.$options);

		// vm.$set  vm.$delete  帮我们更新属性的
		// 新增的属性不会导致视图更新,更改数组的索引也不会更新 
		 	// vm.age.age  = 100  
		 	// vm.$set(vm,'age',100);	// Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.
		 	// 避免在运行时向Vue实例或其根$data添加反应性属性-在data选项中预先声明它
			vm.$set(vm.age,'age',100);		// Object.property


		// 实例属性
		// vm.$el
		// vm.$options		new Vue({}) 整个对象 ===== new Vue时传进去的对象
		// vm.$nextTick
		// $props
		// $parent
		// .$root
		// .$children
		// .$slots
		// .$scopedSlots
		// .$refs
		// $isServer
		// $attrs
		// $listeners

		// 实例方法/数据
		// vm.$watch
		// vm.$set
		// vm.$delete

		// 实例方法/事件
		// $on
		// $once( event, callback )
		// $off( [event, callback] )
		// $emit( eventName, […args] )

		// 实例方法/生命周期
		// vm.$mount
		// vm.$forceUpdate
		// vm.$nextTick
		// vm.$destroy


	</script>
</body>
</html>